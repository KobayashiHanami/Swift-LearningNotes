# 6.0-函数

函数是一段完成特定任务的独立代码片段

本质就是打包的一段代码, 就是把代码模块化,方便复用,不重复造轮子

函数分为: 全局函数/局部函数/系统内建函数/自定义函数

函数也可以作为其他类型的一部分

函数在类和结构体枚举里叫方法

同样的函数名 根据参数不同会有多种版本

| 名词     | 解释                                                         |
| -------- | ------------------------------------------------------------ |
| 函数签名 | 函数名参数名参数类型共同构成                                 |
| 函数名   | 用来描述函数的功能 以供调用使用                              |
| 函数重载 | 函数名相同，但其它方面不同的函数                             |
| 调用     | 使用/运行函数的过程                                          |
| 参数列表 | 跟在函数名后面的小括号,里面放着一个函数所需的所有参数        |
| 参数名   | 函数内部元素的名称,又叫做内部参数                            |
|          |                                                              |
| 参数类型 | 指定传入函数的值的类型                                       |
|          |                                                              |
|          |                                                              |
| 实参     | 写在函数名后面的圆括号中,调用函数时候输入的参数值(实参顺序必须与函数里参数的顺序一致) |
| 全局函数 | 定义在全局域中的函数                                         |
| 嵌套函数 | 定义在别的函数体中的函数                                     |

## 1.定义和调用

以 `func`作为前缀关键词

以 `->`后跟`类型的名称`的方式来表示返回类型

以`return`作为返回值关键字 

```swift
func 函数名(参数标签1 参数1: 参数类型, _ 参数2: 参数类型) -> 类型的名称 {
     执行语句
     return 返回值
}
```

调用函数时,只需要写出函数名并在圆括号中传入要求的实参即可

当函数被调用 就会执行内容并返回结果

```swift
func 打招呼(某人: String) -> String {
    return"对" + 某人 + "说: 你瞅啥!"
}
print(打招呼(某人: "老王"))
```

函数之所以方便复用,就是可以用不同的输入值多次调用,并会返回不同的结果

```swift
print(打招呼(某人: "老王"))
print(打招呼(某人: "老李"))
```

## 2.参数

参数是有名字和类型的值，用来输入给函数使用 参数非常灵活可以复杂或简单

传入函数的参数在函数体内部而言是常量,所以不可更改, 非要改要用输入输出参数

参数可以被定义成任意类型和数量,包括:

### 无参数函数

无参数函数被调用,被调用总是返回固定的内容, 虽然没有参数圆括号也不能省略

```swift
func 打招呼() -> String {
     "你瞅啥"
}
print(打招呼())
```

### 多参数函数

多个参数间用逗号隔开

```swift
func 打招呼(某人: String, 刚才见过吗: Bool) -> String {
    if 刚才见过吗 {
        return"对" + 某人 + "说: 你再瞅一个试试!"
    } else {
        return"对" + 某人 + "说: 你瞅啥!"
    }
}
print(打招呼(某人: "老王", 刚才见过吗: false))
print(打招呼(某人: "老刘", 刚才见过吗: true))
```

### 默认参数值

在函数体内给参数赋一个默认值, 当调用的时候就可以忽略这个参数

习惯将带有默认值的参数放在函数参数列表的最后面,为了阅读清晰

```swift
func 带默认参数值的打招呼(某地: String, 某人: String, 水果: String = "香蕉") -> String {
    "对" + 某地 + "的" + 某人 + "手中的" + 水果 + "大喊: 这是风干的!"
}
print(带默认参数值的打招呼(某地: "达纳苏斯", 某人: "泰兰德"))
print(带默认参数值的打招呼(某地: "塞拉摩", 某人: "吉安娜"))
```

### 可变参数

语法:`数据类型...`

可变参数函数,接受传入不确定數量的参数(零个或多个)

传入的值在函数体中变为此类型的一个数组

​	例如，一个叫做 `a` 的 `Double...` 型可变参数，在函数体内可以当做一个叫 `a` 的 `[Double]` 型的数组常量

```swift
func 今日消费(金额: Double...) -> String{
     var 共计: Double = 0
     for 金额 in 金额 {
         共计 += 金额
     }
    return "今日消费\(共计)元"
}
print(今日消费(金额: 12, 12, 12, 698))
```

一个函数能拥有多个可变参数

可变参数后的第一个行参前必须加上实参标签。实参标签用于区分实参是传递给可变参数，还是后面的行参

### 输入输出参数

函数参数默认是常量,如果你想要一个函数可以修改参数的值，并且想要在这些修改在函数调用结束后仍然存在，就要把这个参数定义为输入输出参数

用参数定义前加`inout`关键字,在传入的参数名前加 `&`符表示

只能传递变量给输入输出参数。

输入输出参数不能有默认值，而且可变参数不能用

输入输出参数和返回值是不一样的。

输入输出参数是函数对函数体外产生影响的另一种方式

这段代码发生了:把两个值传入函数->被函数修改->被函数输出->替换掉原来的值

```swift
func 互换(_ a: inout String, _ b: inout String) {
    let 临时 = a
    a = b
    b = 临时
}

var 早餐 = "煎饼"
var 晚餐 = "火锅"

print("早上吃\(早餐), 晚上吃\(晚餐)")
互换(&早餐, &晚餐)
print("早上吃\(早餐), 晚上吃\(晚餐)")

```

## 3.返回值

函数执行结束时输出的某种类型的值

函数可以定义任何类型和数量的返回值

### 无返回值函数

返回值可以忽略, 没定义可以不写,但函数定义了就必须写

不写返回值,看着是没有,实际上函数会返回一个 `Void` 类型的空元组,写成 `()`

```swift
func 打招呼(谁:String) {
     print("你瞅啥," + 谁)
 }
 打招呼(谁: "老王")
```

### 多返回值函数

用元组类型让多个值作为一个复合值从函数中返回

```swift
func minMax(array: [Int]) -> (min: Int, max: Int) {
     var currentMin = array[0]
     var currentMax = array[0]

     for value in array[1..<array.count] {
         if value < currentMin {
             currentMin = value
         } else if value > currentMax {
             currentMax = value
         }
     }
     return (currentMin, currentMax)
 }

 var sampleArray = [1,2,3,6,7,4,8,99,22,91]
 print(minMax(array: sampleArray))
```

 因为元组成员已被命名,所以可以通过点语法检索

```swift
let bounds = minMax(array: sampleArray)
print("min is \(bounds.min) and max is \(bounds.max)")
```

### 可选元组返回类型

函数返回的元组类型有可能整个元组都“没有值的nil”，即为可选类型

写作 `(Int, Int)?` 或 `(String, Int, Bool)?`

注意区分可选元组类型如 `(Int, Int)?` 与元组包含可选类型如 `(Int?, Int?)` 的区别

当传入的数组是空时,函数在访问 `array[0]` 时会触发错误,所以代码更改如下:

```swift
func minMax(array: [Int]) -> (min: Int, max: Int)? {
    if array.isEmpty { return nil }
    var currentMin = array[0]
    var currentMax = array[0]

    for value in array[1..<array.count] {
        if value < currentMin {
            currentMin = value
        } else if value > currentMax {
            currentMax = value
        }
    }
    return (currentMin, currentMax)
}
```

可以使用可选绑定来检查 `minMax(array:)` 函数返回的是一个存在的元组值还是 `nil`：

```swift
if let bounds = minMax(array: [8, -6, 2, 109, 3, 71]) {
    print("min is \(bounds.min) and max is \(bounds.max)")
}
```

### 隐式返回函数

如果整个函数体是一个单行表达式,即只有一行代码时

关键字`return`可以省略

```swift
func 打招呼(对 某人: String) -> String {
    "对" + 某人 + "说: 你瞅啥!"
}
print(打招呼(对: "老王"))
```

## 4.参数标签

函数的每一个参数都有自己的参数标签和参数名称

翻译和习惯的原因导致的多个中文名: 参数标签/外部参数/调用参数

参数标签就是参数另一个名字 类似名诸葛亮 字孔明 号卧龙

参数标签写在参数名称前用空格分隔 

参数标签不用可以用`_`下划线代替

默认情况下不写参数标签, 参数名称就是参数标签, 但写了就必须要用

```swift
func 函数名(参数标签 参数名:参数类型){}
func 函数名(_ 参数名:参数类型){}
func 函数名(参数名:参数类型){}
```

参数名在函数的实现中使用(內部使用)

参数标签在调用函数的时候使用(外部使用)

```swift
func 打招呼(某地: String, 某人: String) -> String {
    "对" + 某地 + "的" + 某人 + "说: 你瞅啥!"
}

func 带参数标签的打招呼(来自 某地: String, 的 某人: String) -> String {
    "对" + 某地 + "的" + 某人 + "说: 你瞅啥!"
}
print(打招呼(某地: "法戈第矿洞", 某人: "金牙"))
print(带参数标签的打招呼(来自: "艾尔文森林", 的: "霍格"))

```

参数标签是为了让代码阅读更像英文自然表达,对于中文相对鸡肋

## 5.函数类型

每个函数都特定的函数类型

一个函数的参数类型确定了 返回类型确定了 函数的类型也就确定了

```swift
(参数 1: 类型, 参数 2: 类型) -> 返回值:类型
```

这两个函数的类型都是`(Int, Int) -> Int`,即 有兩個 Int 参数,并返回 Int 类型的函数

```swift
func 相加(_ a: Int, _ b: Int) -> Int {
    return a + b
}

func 相乘(_ a: Int, _ b: Int) -> Int {
    return a * b
}
```

这个函数的类型是：`() -> Void`，即“没有参数也沒有返回值的函数”

```swift
func printHelloWorld() {
    print("hello, world")
}
```

### 函数类型使用

使用函数的类型跟使用其他任何类型一样

可以定义一个类型为函数的常量或变量,然后再赋值

这段代码可以被解读为：

声明一个函数类型的变量, 并赋给它加法这个函数

```swift
func 加法(_ a: Int, _ b: Int) -> Int {
    return a + b
}
func 乘法(_ a: Int, _ b: Int) -> Int {
    return a * b
}

var 数学运算: (Int, Int) -> Int = 加法
print(数学运算(3,2))
```

类型相同的不同函数,可以被赋值给同一个变量,就像其他变量一样

```swift
数学运算 = 乘法
print(数学运算(3, 2))
```

当把一个函数赋值给常量或变量时，你可以让 Swift 会自动类型推断,就像其他类型一样

```swift
var 新的运算 = 加法
print(type(of: 新的运算))
//Prints: (Int, Int) -> Int
```

### 函数类型作为参数类型

作用就是输出另一个符合类型的数学函数的调用结果

它不关心传入函数是如何实现的，只关心传入的函数是不是一个正确的类型。

可以用符合类型安全的方式,将函数的一部分功能实现留给函数的调用者来提供。

```swift
func 加法(_ a: Int, _ b: Int) -> Int {
    return a + b
}
func 乘法(_ a: Int, _ b: Int) -> Int {
    return a * b
}

/*
 这是函数类型: (Int, Int) -> Int
 这是一个函数: func 函数(参数 1: 类型, 参数 2: 类型) -> 返回类型
 放进去:func 函数(参数 1: (Int, Int) -> Int, 参数 2: 类型) -> 返回类型
*/
func 输出运算结果(_  a: (Int, Int) -> Int, _ b: Int, _ c: Int) {
    print("结果是: \(a(b, c))")
}
输出运算结果(加法, 3, 5)

/*
 这个函数定义了三个参数,a 的类型是函数,bc 的类型是 Int.
 当 输出运算结果 被调用,传入了 加法 这个函数和 整数 3 和 5
 在函数内部的打印语句中,用 3 和 5,作为了函数 加法 的参数,并输出了计算结果
 */
```

### 作为返回类型

```swift
func 向前一步(_ 输入: Int) -> Int {
    return 输入 + 1
}
func 向后一步(_ 输入: Int) -> Int {
    return 输入 - 1
}
/*
 这两个都是(Int) -> Int类型
 向前一步 输入一个数字,会返回一个比自身大 1 的值
 向后一步同理
 */

func 选择步数函数(向后: Bool) -> (Int) -> Int {
    return 向后 ? 向后一步 : 向前一步
}
/*
 这个 选择步数 函数,返回类型是(Int) -> Int
 选择步数 函数根据布尔值 向后 来返回 函数 向后一步 或 向前一步
 */

var 当前值 = 10
let 靠近零 = 选择步数函数(向后: 当前值 > 0)
/*
 给了当前值是 3,
 声明了一个靠近零的函数类型常量,然后赋值为 选择步数函数
 把判断当前值是否大于零作为布尔条件,大于零为真
 因此,`选择步数函数`会返回`向后一步`函数。一个指向返回的函数的引用保存在了`靠近零`常量中。
 */

//现在`靠近零`可以用来倒计时
while 当前值 != 0 {
    print("\(当前值)... ")
    当前值 = 靠近零(当前值)
}
print(" 0!")
// 3...
// 2...
// 1...
// zero!
```

## 6.嵌套函数

默认情况下，嵌套函数是对外界不可见的，但是可以被包裹它们的「外围函数 enclosing function」调用

一个外围函数可以返回它的某一个嵌套函数，使得这个函数可以在其他域中被使用

用返回嵌套函数的方式重写 选择步数函数：

```swift
func 选择步数函数(向后: Bool) -> (Int) -> Int {
    func 向前一步(输入: Int) -> Int { return 输入 + 1 }
    func 向后一步(输入: Int) -> Int { return 输入 - 1 }
    return 向后 ? 向后一步 : 向前一步
}
var 当前值 = -4
let 靠近零 = 选择步数函数(向后: 当前值 > 0)

while 当前值 != 0 {
    print("\(当前值)... ")
    当前值 = 靠近零(当前值)
}
print("0!")
```

## 7.投掷函数

有时函数会因为输入错误或内部出现问题而失败。Swift 允许我们通过将函数标记为`throws`返回类型之前来抛出错误，然后`throw`在出现问题时使用关键字。

首先我们需要定义一个`enum`描述我们可以抛出的错误。这些必须始终基于 Swift 的现有`Error`类型。

使用三个新关键字调用这些函数：`do`开始一段可能导致问题的代码，`try`在每个可能引发错误的函数之前使用，并`catch`让您优雅地处理错误。

---

以上