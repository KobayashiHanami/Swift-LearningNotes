# 9.0-类和结构体

当数据复杂到无法使用元组管理时 就要使用类结构体和枚举 制作自定义类型

定义的每一个枚举/结构/类体都是一个全新的数据类型, 所以命名用大驼峰

Swift语言只需在单一的文件中定义一个结构体或者类，系统将会自动生成面向其它代码的外部接口

Swift 中的实例 就是其他编程语言的对象

Swift 中没有指针的概念

翻译

由于翻译和称呼习惯的原因 以下内容在类和结构体中完全等价 只是叫法不同

1. 存储 === 静态 === 类型 === 对象
2. 私有 === 内部

3. 构造 === 实例化 === 初始化 === 启动方式
4. 初始化器 === 构造器



名词解释

- 属性: 定义在类、结构体或枚举中的常量和变量
- 类型属性: 定义在模型本身的属性
- 计算属性: 直接计算值的属性
- 方法: 在类/枚举/结构体内部定义的函数 默认就是静态/类型
- 类型方法: 定义在模型本身的方法
- 实例方法: 方法一般都会定义在实例中
- 下标: 在类结构体枚举中定义的,访问集合、列表或序列中元素的快捷方式
- 可选链: 在当前值可能为 nil的可选值上请求和调用属性、方法及下标的方法



常见关键词

- ` static` 
  - 属性和方法默认都是实例的
  - 静态属性不需要实例,它属于类型本身 要先赋值
  - 直接与类型本身关联 无论创建了多少个该类型的实例，这些属性都只有唯一一份
- `private`
  - 限制了权限 只能在当前类和结构体中访问
  - 加了私有以后,要手动写初始化器或者有默认值
- `mutating`
  - 在实例方法中修改值类型
  - 默认情况下，值类型的属性不能在它的实例方法中被修改
  - 即可从方法修改属性, 即修改实例本身,自己修改自己
  - `init`默认就是`mutating`的
  - 可变方法能够赋给隐含属性 `self` 一个全新的实例
- 在下标前面加` class/struct` 可以对类型进行操作

## 1.定义和实例化

### 定义

关键字`struct`声明结构体

关键字`class`声明类

```swift
struct 结构体名字 {
   var 属性名 = 默认值
   var 属性名: 属性类型
 }

 class 类名字 {
   var 属性名 = 默认值
   var 属性名: 属性类型
 }
```

### 实例化

声明的类和结构体仅仅是数据模型,因此需要创建实例 即实例化

构造器语法的最简单形式是在结构体或者类的类型名称后跟随一对空括号

通过这种方式所创建的类或者结构体实例，其属性均会被初始化为默认值

根据 人类的结构模型 实例化出老王和豆豆

```swift
import Foundation

class  动物 {
    var 品种 = "🐱"
    var 毛色 = "橘"
}
struct 人类 {
    let 胳膊的数量 = 2
    let 眼睛的数量 = 2
    var 身高 = 170
    var 宠物 = 动物()
}

var 老王 = 人类()
var 豆豆 = 动物()
```

### 操作属性

通过使用点语法`.`访问或更改实例的属性以及子属性

```swift
print(老王.胳膊的数量)
print(老王.宠物.品种)
老王.身高 = 180
老王.宠物.品种 = "🐶"
print(老王.身高)
print(老王.宠物.品种)
```

## 2.对比

### 共同点

都是对一个资料/模型的抽象数据结构

都可以定义属性用于存储

都可以定义方法用于提供功能

都可以定义下标用于访问值

都可以定义构造器用于初始值

都可以遵循协议,以提供标准功能

都可以通过扩展以增加默认实现之外的功能

### 类特有

引用类型

可继承

被声明为常量,内部的变量属性依然可以更改

只要有属性,就必须写明初始化器

类型转换允许在运行时检查和解释一个类实例的类型

析构器允许一个类实例释放任何其所被分配的资源

引用计数允许对一个类的多次引用

类和 actors 共享很多特性。更多信息请参见 [并发]()。

恒等运算符

​	使用恒等运算符`===`和`!==`判断是否引用同一个实例

​	因为类是引用类型，所以多个常量和变量可能在幕后同时引用同一个类实例。

### 结构体特有

结构体是 Swift 语言的核心组成部分， [Int](https://developer.apple.com/documentation/swift/int)、 [Double](https://developer.apple.com/documentation/swift/double)、[Array](https://developer.apple.com/documentation/swift/array)、[Dictionary](https://developer.apple.com/documentation/swift/dictionary)等数据类型核心都是用结构体实现的

值类型

被声明为常量时,内部的属性也无法更改

拥有静态空间和实例空间

自带默认的初始化器(成员逐一构造器)

## 4.区分一些概念

### 全局变量和局部变量

计算属性和观察属性所描述的功能也可以用于全局变量和局部变量

全局或局部变量都属于存储型变量，跟存储属性类似，它为特定类型的值提供存储空间，并允许读取和写入。

在全局或局部范围都可以定义计算型变量和为存储型变量定义观察器。计算型变量跟计算属性一样，返回一个计算结果而不是存储值，声明格式也完全一样。

全局的常量或变量都是延迟计算的，跟 延时加载存储属性 相似，不同的地方在于，全局的常量或变量不需要标记 `lazy` 修饰符。

局部范围的常量和变量从不延迟计算。

### 值类型和引用类型

值类型

当被赋或被传递时，其值会被复制

所有的改动都是基于新的实例,跟别人没关系

当值类型的实例被声明为常量的时候，它的所有属性也就成了常量

结构体枚举和Swift 中所有的基本类型(整型浮点布尔字符串数组字典枚举)都是值类型

标准库定义的集合，例如数组，字典和字符串，都对复制进行了优化以降低性能成本。

新集合不会立即复制，而是跟原集合共享同一份内存，共享同样的元素。在集合的某个副本要被修改前，才会复制它的元素。

引用类型

当被赋或被传递时，其值会被引用。即快捷方式

所有的改动都是对一个类进行操作

因为类是引用类型，所以多个常量和变量可能在幕后同时引用同一个类实例

当引用类型的实例被声明为常量的时候，依然可以修改该实例的可变属性。

使用恒等运算符(等价或全等)`=== ≠==`判断其是否引用自同一个类的实例

Swift 中没有指针概念 因为引用类型的数据并不直接指向某个内存地址

如果需要直接与指针交互，使用指针和缓冲区类型 —— 参见 [手动管理内存](https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management)

### 选择结构体还是类

适用于反复使用的框架一般定义为 class

不适合反复使用的实体常被定义为 struct

类支持的附加功能是以增加复杂性为代价的

作为一般准则，Swift优先使用结构体和枚举

更多详细的比较参见官方指导 [在结构和类之间进行选择](https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes) 

### 方法和函数

`method`和`function`

唯一的区别是作用域不同

函数是全局都可以调用的

方法是被限定使用类型的范围里,只在他被构造的范围内有效 所以方法前面有`.`

### 属性和方法

```swift
 人类 的类型
 人类.手的数量 = 2
 人类.眼睛的数量 = 2
 人类.是否直立行走 = true
 人类.是否有尾巴 = false
 人类.用火()
 人类.最快奔跑速度()
 人类.女娲的小皮鞭()

 let 人类1 = 人类(名字: 老王,身高:180, 体重: 200)
 .init人类(名字:String,身高:Int, 体重: Int)
 老王.体重
 老王.身高
```

定义的变量叫做实例属性,用于存储值,只能通过实例访问

实例在被建立以前是不存在的,所以可以先不赋值

定义的函数叫做方法,用于提供功能

定义下标操作用于通过下标语法访问它们的值

定义构造器用于设置初始值

### 重载和重写

重载

`Overload`名称相同但功能不同的方法类运算符函数初始化器等

重写

在子类中定义和父类同名方法

存储属性不能重写

计算属性可以

防止重写

### 类型和实例设计准则

需要提前思考 一个属性或者方法 到底设计成实例还是类型

考虑关联性: 是否针对每一个实例都拥有独立的特征 独立性越强越适合作为类型属性/方法 比如出厂批次这样的数据

### 访问权限控制关键词

```swift
open > Pubilc > internal > fileprivate > private
```

open 最高权限

> Pubilc 
>
> > internal 啥都不写的默认权限
> >
> > > fileprivate 当前文件权限
> > >
> > > > private 当前类或结构体内部权限

---

以上