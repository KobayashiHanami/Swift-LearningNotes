# 7-闭包

闭包是自包含的函数代码块 

类似于其他编程语言中的`代码块`或`匿名函数`概念

可以粗暴地理解为 闭包就是没有命名的函数 函数就是有名字的闭包

闭包是精简代码的一种体现，不过常因其省略过多让人觉得不好理解。

闭包是引用类型

闭包采用三种形式：

- 全局函数: 是一个有名字但不会捕获任何值的闭包
- 嵌套函数: 是一个有名字并可以捕获其封闭函数域内值的闭包
- 闭包表达式: 是一个利用轻量级语法所写的 可以捕获其上下文中变量或常量值的匿名闭包

## 1.闭包表达式

闭包表达式是一种构建内联闭包的简洁方式

闭包表达式可以是 `in-out` 参数，但不能设定默认值。

Swift 的闭包表达式拥有简洁的风格，并鼓励在常见场景中进行语法优化，能省略的全省略:

- 利用上下文推断参数和返回值类型
- 隐式返回单表达式闭包，即单表达式闭包可以省略 `return` 关键字
- 参数名称缩写,可以直接通过 `$0`，`$1`，`$2`来顺序调用闭包的参数。
- 尾随闭包语法
- 对于有闭包作为参数的函数，若其最后一个参数为闭包，则可以省略参数标签及括号。
- 如果闭包是函数最后一个参数或唯一及参数, 参数可以简写成`$123...`
- 如果有多个参数,只能省略第一个参数名称,比如SwiftUI 中的`ButtonView`

闭包表达式参数 可以是 in-out 参数，但不能设定默认值。

如果你命名了可变参数，也可以使用此可变参数。元组也可以作为参数和返回值。

闭包表达式语法有如下的一般形式：

```swift
{ (parameters) -> return type in
    statements
}
```

## 2.尾随闭包

尾随闭包是一个书写在函数圆括号之后的闭包表达式

需要将闭包表达式放在最后一个参数位置

函数支持将其作为最后一个参数调用

尾随闭包不需要写出它的参数标签

适用场景: 闭包非常长以至于不能在一行中进行书写时

```swift
func someFunctionThatTakesAClosure(closure: () -> Void) {
    // 函数体部分
}

// 不使用尾随闭包进行函数调用
someFunctionThatTakesAClosure(closure: {
    // 闭包主体部分
})

// 使用尾随闭包进行函数调用
someFunctionThatTakesAClosure() {
    // 闭包主体部分
}
```

## 3.值捕获

闭包可以在其被定义的上下文中捕获常量或变量。

即使定义这些常量和变量的原作用域已经不存在，闭包仍然可以在闭包函数体内引用和修改这些值。

Swift 中可以捕获值的闭包的最简单形式是嵌套函数，嵌套函数可以捕获其外部函数所有的参数以及定义的常量和变量。

## 4.逃逸闭包

闭包可以捕获和存储其所在上下文中任意常量和变量的引用。被称为包裹常量和变量。 Swift 会自动管理在捕获过程中涉及到的所有内存操作。

逃逸是指 当一个闭包作为参数传到一个函数中，但是这个闭包在函数返回之后才被执行

在参数名之前标注 `@escaping`，用来指明该闭包是允许“逃逸”的。

一种能使闭包“逃逸”出函数的方法是，将这个闭包保存在一个函数外部定义的变量中。

## 5.自动闭包

使用`@autoclosure`表示

自动闭包是一种自动创建的闭包，用于包装传递给函数 作为参数的表达式。

这种闭包不接受任何参数，当它被调用的时候，会返回被包装在其中的表达式的值。

这种便利语法让你能够省略闭包的花括号，用一个普通的表达式来代替显式的闭包。

自动闭包让你能够延迟求值，因为直到你调用这个闭包，代码段才会被执行。

## 6.简化示例

在保证不丢失它语法清晰明了的同时，闭包表达式提供了几种优化的语法简写形式

这个例子通过对案例,展示功能不变下, 多次改进迭代愈发简洁的过程

我们要对`name`这个字符串数组用`sorted(by:)` 方法进行逆序排序

```swift
let names = ["唐僧", "孙悟空", "猪八戒", "沙和尚", "白龙马"]
```

`sorted(by:)` 方法接受一个闭包

该闭包函数需要传入与数组元素类型相同的两个值，并返回一个布尔类型值来表明当排序结束后传入的第一个参数排在第二个参数前面还是后面。如果第一个参数值出现在第二个参数值*前面*，排序闭包函数需要返回 `true`，反之返回 `false`。

该例子对一个 `String` 类型的数组进行排序，因此排序闭包函数类型需为 `(String, String) -> Bool`。

提供排序闭包函数的一种方式是撰写一个符合其类型要求的普通函数，并将其作为 `sorted(by:)` 方法的参数传入：

```swift
let names = ["唐僧", "孙悟空", "猪八戒", "沙和尚", "白龙马"]

func 反向(_ s1: String, _ s2: String) -> Bool {
    return s1 > s2
}
var 反转名字 = names.sorted(by: 反向)
```

如果第一个字符串（`s1`）大于第二个字符串（`s2`），`反向(_:_:)` 函数会返回 `true`，表示在新的数组中 `s1` 应该出现在 `s2` 前。

对于字符串中的字符来说，“大于”表示“按照字母顺序较晚出现”。

然而，以这种方式来编写一个实际上很简单的表达式（`a > b`)，确实太过繁琐了。对于这个例子来说，利用闭包表达式语法可以更好地构造一个内联排序闭包。

### 把代码更新为闭包表达式版本

```swift
反转名字 = names.sorted(by: { (s1: String, s2: String) -> Bool in
    return s1 > s2
})
```

需要注意的是内联闭包参数和返回值类型声明与 `backward(_:_:)` 函数类型声明相同。在这两种方式中，都写成了 `(s1: String, s2: String) -> Bool`。

在内联闭包表达式中，函数和返回值类型都写在*大括号内*，而不是大括号外

闭包的函数体部分由关键字 `in` 引入。该关键字表示闭包的参数和返回值类型定义已经完成，闭包函数体即将开始。

由于这个闭包的函数体部分如此短，以至于可以将其改写成一行代码：

```swift
反转名字 = names.sorted(by: { (s1: String, s2: String) -> Bool in return s1 > s2 })
```

现在该例中 `sorted(by:)` 方法的整体调用保持不变，一对圆括号仍然包裹住了方法的整个参数。然而，参数现在变成了内联闭包。

### 根据上下文推断类型

因为排序闭包函数是作为 `sorted(by:)` 方法的参数传入的，Swift 可以推断其参数和返回值的类型。`sorted(by:)` 方法被一个字符串数组调用，因此其参数必须是 `(String, String) -> Bool` 类型的函数。这意味着 `(String, String)` 和 `Bool` 类型并不需要作为闭包表达式定义的一部分。因为所有的类型都可以被正确推断，返回箭头（`->`）和围绕在参数周围的括号也可以被省略：

```swift
反转名字 = names.sorted(by: { s1, s2 in return s1 > s2 } )
```

实际上，通过内联闭包表达式构造的闭包作为参数传递给函数或方法时，总是能够推断出闭包的参数和返回值类型。这意味着闭包作为函数或者方法的参数时，你几乎不需要利用完整格式构造内联闭包。

尽管如此，你仍然可以明确写出有着完整格式的闭包。如果完整格式的闭包能够提高代码的可读性，则我们更鼓励采用完整格式的闭包。而在 `sorted(by:)` 方法这个例子里，显然闭包的目的就是排序。由于这个闭包是为了处理字符串数组的排序，因此读者能够推测出这个闭包是用于字符串处理的。

### 单表达式闭包的隐式返回

单行表达式闭包可以通过省略 `return` 关键字来隐式返回单行表达式的结果，如上版本的例子可以改写为：

```swift
反转名字 = names.sorted(by: { s1, s2 in s1 > s2 } )
```

在这个例子中，`sorted(by:)` 方法的参数类型明确了闭包必须返回一个 `Bool` 类型值。因为闭包函数体只包含了一个单一表达式（`s1 > s2`），该表达式返回 `Bool` 类型值，因此这里没有歧义，`return` 关键字可以省略。

### 参数名称缩写

Swift 自动为内联闭包提供了参数名称缩写功能，你可以直接通过 `$0`，`$1`，`$2` 来顺序调用闭包的参数，以此类推。

如果你在闭包表达式中使用参数名称缩写，你可以在闭包定义中省略参数列表，并且对应参数名称缩写的类型会通过函数类型进行推断。闭包接受的参数的数量取决于所使用的缩写参数的最大编号。`in` 关键字也同样可以被省略，因为此时闭包表达式完全由闭包函数体构成：

```swift
反转名字 = names.sorted(by: { $0 > $1 } )
```

在这个例子中，`$0` 和 `$1` 表示闭包中第一个和第二个 `String` 类型的参数。因为 `$1` 是编号最大的缩写参数，所以可以理解为：该闭包需要两个参数。这里的 `sorted(by:)` 函数希望得到一个参数都是字符串的闭包，因此缩写参数 `$0` 和 `$1` 的类型均为 `String`。

### 运算符方法

实际上还有一种更*简短的*方式来编写上面例子中的闭包表达式。Swift 的 `String` 类型定义了关于大于号（`>`）的字符串实现，其作为一个函数接受两个 `String` 类型的参数并返回 `Bool` 类型的值。而这正好与 `sorted(by:)` 方法的参数需要的函数类型相符合。因此，你可以简单地传递一个大于号，Swift 可以自动推断找到系统自带的那个字符串函数的实现：

```swift
反转名字 = names.sorted(by: >)
```

### 使用尾随闭包改写

作为尾随包的形式改写在 `sorted(by:)` 方法圆括号的外面：

```swift
反转名字 = names.sorted() { $0 > $1 }
```

如果闭包表达式是函数或方法的唯一参数，则当你使用尾随闭包时，你甚至可以把 `()` 省略掉：

```swift
反转名字 = names.sorted { $0 > $1 }
```

---

以上
