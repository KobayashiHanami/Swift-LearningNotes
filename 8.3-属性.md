# 10.0-属性

属性将值与特定的自定义数据类型关联。

存储属性会将常量和变量存储为实例的一部分，

而计算属性则是直接计算（而不是存储）值。

计算属性可以用于全部自定义数据类型，而存储属性枚举不能用。

存储属性和计算属性通常与特定类型的实例关联。但是，属性也可以直接与类型本身关联，这种属性称为类型属性。

另外，还可以定义属性观察器来监控属性值的变化，以此来触发自定义的操作。属性观察器可以添加到类本身定义的存储属性上，也可以添加到从父类继承的属性上。

你也可以利用属性包装器来复用多个属性的 getter 和 setter 中的代码。

## 1.存储属性

一个存储属性就是存储在特定类或结构体实例里的常量和变量。枚举不可用

存储属性可以指定默认值,也可以在构造过程中设置或修改存储属性的值，甚至修改常量存储属性的值

🌰:用结构体描述了一个整数区间 

`固定长度范围`是模型

`三个长度范围`是用模型创建的实例,

其中的`第一个值`和`长度`两个属性在实例化时初始化为具体的值

```swift
struct 固定长度范围 {
    var 第一个值: Int
    let 长度: Int
}
var 三个长度范围 = 固定长度范围(第一个值: 0, 长度: 3)
// 该区间表示整数 0，1，2
三个长度范围.第一个值 = 6
// 该区间现在表示整数 6，7，8
```

### 常量结构体实例的存储属性

一个常量结构体实例, 无法修改该实例的任何属性，即使被声明为可变属性也不行

### 延时加载存储属性

当第一次被调用的时候才会计算其初始值的属性

关键字 `lazy`

必须声明成变量`var`

因为属性的初始值可能在实例构造完成之后才会得到.而常量属性在构造过程完成之前必须要有初始值，因此无法声明成延时加载。

在没有初始化时就同时被多个线程访问，则无法保证该属性只会被初始化一次。

## 2.计算属性

计算属性不直接存储值

而是提供一个 `getter `和一个可选的 `setter`

通过计算 来间接获取和设置其他属性或变量的值

必须使用变量`var`定义计算属性，包括只读计算属性，因为它们的值不是固定的

## 简化

如果计算属性的 `setter` 没有定义表示新值的参数名，则可以使用默认名称 `newValue`

如果整个 `getter` 是单一表达式，`getter` 会隐式地返回这个表达式结果

在` getter` 中忽略 `return`与在函数中忽略 `return`的规则相同

## 只读计算属性

只有` getter` 没有` setter` 的计算属性叫只读计算属性

只读计算属性总是返回一个值，可以访问不能更改

只读计算属性的声明可以去掉 `get`关键字和花括号

# 属性观察器

`willSet`和`didSet`,监控属性值的变化,触发自定义的操作

属性观察器监控和响应属性值的变化，每次属性被设置值的时候都会调用属性观察器，即使新值和当前值相同的时候也不例外。

可以在以下位置添加属性观察器：

- 自定义的存储属性
- 继承的存储属性
- 继承的计算属性

如果将带有观察器的属性通过 `in-out `方式传入函数，属性观察器同样会被调用

`willSet`在新的值被设置之前调用

会将新的属性值作为常量参数传入

在其实现代码中可以为这个参数指定一个名称，或默认使用参数名 `newValue`

`didSet`在新的值被设置之后调用

会将旧的属性值作为参数传入

可以为该参数指定一个名称或默认使用参数名 `oldValue`。

如果在 `didSet` 方法中再次对该属性赋值，那么新值会覆盖旧的值。

```swift
class 打工赚钱 {
	var 今天赚的钱: Int = 0 {
		willSet(今天的) {
			print("今天赚了\(今天的)元")
		}
		didSet {
			print("昨天赚了\(oldValue) 元")
		}
	}
}

let 老王去工作 = 打工赚钱()
老王去工作.今天赚的钱 = 500
老王去工作.今天赚的钱 = 800
老王去工作.今天赚的钱 = 1000
```

## 可以添加观察器的属性

自定义的存储属性-使用它的 setter 监控和响应值的变化，而不是尝试创建观察器。

继承的存储属性-在子类中重写属性为它添加属性观察器

继承的计算属性-在子类中重写属性为它添加属性观察器

# 属性包装器

定义属性的代码 和 管理属性如何存储 之间的分隔层。

复用多个属性的` getter` 和 `setter `中的代码

适用类结构体或枚举

### 定义属性包装器

关键词 `@wrappedValue`

```swift
@propertyWrapper
struct 最多报销一百块 {
	private var number = 0
	var wrappedValue: Int {
		get { return number }
		set { number = min(newValue, 100) }
	}
}
```

### 使用属性包装器

在属性之前写上包装器名称，就可以把一个包装器应用到一个属性上去

```swift
import UIKit
import Foundation

@propertyWrapper
struct 最多报销一百块 {
	private var 实际报销金额 = 0
	var wrappedValue: Int {
		get { return 实际报销金额 }
		set { 实际报销金额 = min(newValue, 100) }
	}
}

struct 每天花销 {
	@最多报销一百块 var 早餐: Int
	@最多报销一百块 var 午餐: Int
	@最多报销一百块 var 晚餐: Int
}

var 今天 = 每天花销()
print(今天.早餐)

今天.午餐 = 50
print(今天.午餐)

今天.晚餐 = 300
print(今天.晚餐)

/*
 早餐午餐晚餐属性从 最多报销一百块 的定义中获它们的初始值
	该定义把 最多报销一百块.报销金额 设置默认为0,所以不输入值,就是默认的0
	午餐输入的是50,存储成过,报销50
	晚餐的300,对于这个属性的 setter 的规则来说,超过了设定上限100,所以大于100的都报销100
 */
```

## 设置被包装属性的初始值

上面的例子中,代码通过 最多报销一百块 内的定义中赋值 报销金额 的初始值,作为被包装属性的初始值.

所以当使用了这个包装器的代码,就无法指定其初始值,想要让其支持设定初始值或其他自定义操作,需要添加一个新的构造器.以下是更新后的 最多报销一百块 扩展版本

当你包装器应用于属性且没有设定初始值时，Swift 使用 `init()`构造器来设置包装器。

当你属性指定初始值时，Swift 使用 `init(wrappedValue:)`构造器来设置包装器。

当你在自定义特性后面把实参写在括号里时，Swift 使用接受这些实参的构造器来设置包装器。

通过将实参包含到属性包装器中，你可以设置包装器的初始状态，或者在创建包装器时传递其他的选项。这种语法是使用属性包装器最通用的方法。你可以为这个属性提供任何所需的实参，且它们将被传递给构造器。

当包含属性包装器实参时，你也可以使用赋值来指定初始值。Swift 将赋值视为 `wrappedValue` 参数，且使用接受被包含的实参的构造器。

## 从属性包装器中呈现一个值

除了被包装值，属性包装器可以通过定义被呈现值暴露出其他功能。

属性包装器可以返回任何类型的值作为它的被呈现值。

# 类型属性

为类型本身定义属性，无论创建了多少个该类型的实例，这些属性都只有唯一一份。这种属性就是*类型属性*。

关键字 `static` 来定义类型属性

## 操作类型属性

类型属性也是通过点运算符来访问。但是，类型属性是通过*类型*本身来访问，而不是通过实例。

```swift
print(SomeStructure.xxx)
```

